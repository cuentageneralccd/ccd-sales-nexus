
import { useState, useEffect, useCallback } from 'react';
import { vicidialService } from '@/services/vicidialService';
import { useToast } from '@/hooks/use-toast';

interface KPIDefinition {
  id: string;
  name: string;
  description: string;
  category: 'PRODUCTIVITY' | 'QUALITY' | 'EFFICIENCY' | 'REVENUE' | 'CUSTOMER_SATISFACTION';
  calculationMethod: 'COUNT' | 'PERCENTAGE' | 'AVERAGE' | 'RATIO' | 'SUM';
  numerator: string;
  denominator?: string;
  unit: string;
  targetValue: number;
  criticalValue: number;
  warningValue: number;
  frequency: 'REALTIME' | 'HOURLY' | 'DAILY' | 'WEEKLY' | 'MONTHLY';
  isActive: boolean;
  weight: number; // Para cálculo de score general
}

interface KPIResult {
  kpiId: string;
  advisorId: string;
  value: number;
  target: number;
  percentage: number;
  status: 'EXCELLENT' | 'GOOD' | 'WARNING' | 'CRITICAL';
  trend: 'IMPROVING' | 'STABLE' | 'DECLINING';
  lastCalculated: string;
  historicalData: {
    date: string;
    value: number;
  }[];
}

interface AdvancedAlert {
  id: string;
  advisorId: string;
  advisorName: string;
  type: 'KPI_CRITICAL' | 'KPI_WARNING' | 'PATTERN_ANOMALY' | 'GOAL_ACHIEVEMENT' | 'ESCALATION_REQUIRED';
  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  kpiId?: string;
  kpiName?: string;
  currentValue: number;
  targetValue: number;
  deviation: number;
  message: string;
  actionRequired: string;
  suggestedActions: string[];
  createdAt: string;
  acknowledgedAt?: string;
  acknowledgedBy?: string;
  resolvedAt?: string;
  resolvedBy?: string;
  escalatedAt?: string;
  escalatedTo?: string;
  priority: number;
  autoGenerated: boolean;
  relatedAlerts: string[];
  metadata: Record<string, any>;
}

interface AdvisorPerformanceProfile {
  advisorId: string;
  advisorName: string;
  totalScore: number;
  categoryScores: {
    productivity: number;
    quality: number;
    efficiency: number;
    revenue: number;
    customerSatisfaction: number;
  };
  kpiResults: KPIResult[];
  activeAlerts: AdvancedAlert[];
  performanceTrend: 'IMPROVING' | 'STABLE' | 'DECLINING';
  riskLevel: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  strengths: string[];
  improvementAreas: string[];
  recommendations: string[];
  lastEvaluated: string;
  nextEvaluation: string;
}

const STANDARD_KPIS: KPIDefinition[] = [
  {
    id: 'CALLS_PER_HOUR',
    name: 'Llamadas por Hora',
    description: 'Número de llamadas realizadas por hora trabajada',
    category: 'PRODUCTIVITY',
    calculationMethod: 'RATIO',
    numerator: 'total_calls',
    denominator: 'work_hours',
    unit: 'llamadas/hora',
    targetValue: 15,
    criticalValue: 8,
    warningValue: 12,
    frequency: 'HOURLY',
    isActive: true,
    weight: 0.15
  },
  {
    id: 'CONTACT_RATE',
    name: 'Tasa de Contacto',
    description: 'Porcentaje de llamadas que resultan en contacto efectivo',
    category: 'EFFICIENCY',
    calculationMethod: 'PERCENTAGE',
    numerator: 'contacts',
    denominator: 'total_calls',
    unit: '%',
    targetValue: 35,
    criticalValue: 20,
    warningValue: 28,
    frequency: 'DAILY',
    isActive: true,
    weight: 0.20
  },
  {
    id: 'CONVERSION_RATE',
    name: 'Tasa de Conversión',
    description: 'Porcentaje de contactos que resultan en venta',
    category: 'REVENUE',
    calculationMethod: 'PERCENTAGE',
    numerator: 'sales',
    denominator: 'contacts',
    unit: '%',
    targetValue: 12,
    criticalValue: 5,
    warningValue: 8,
    frequency: 'DAILY',
    isActive: true,
    weight: 0.25
  },
  {
    id: 'AVERAGE_CALL_TIME',
    name: 'Tiempo Promedio de Llamada',
    description: 'Duración promedio de las llamadas en segundos',
    category: 'EFFICIENCY',
    calculationMethod: 'AVERAGE',
    numerator: 'total_talk_time',
    denominator: 'total_calls',
    unit: 'segundos',
    targetValue: 240,
    criticalValue: 120,
    warningValue: 180,
    frequency: 'HOURLY',
    isActive: true,
    weight: 0.10
  },
  {
    id: 'QUALITY_SCORE',
    name: 'Puntuación de Calidad',
    description: 'Puntuación promedio de las evaluaciones de calidad',
    category: 'QUALITY',
    calculationMethod: 'AVERAGE',
    numerator: 'quality_evaluations_sum',
    denominator: 'quality_evaluations_count',
    unit: 'puntos',
    targetValue: 85,
    criticalValue: 60,
    warningValue: 70,
    frequency: 'DAILY',
    isActive: true,
    weight: 0.20
  },
  {
    id: 'CUSTOMER_SATISFACTION',
    name: 'Satisfacción del Cliente',
    description: 'Puntuación promedio de satisfacción del cliente',
    category: 'CUSTOMER_SATISFACTION',
    calculationMethod: 'AVERAGE',
    numerator: 'satisfaction_scores_sum',
    denominator: 'satisfaction_surveys_count',
    unit: 'puntos',
    targetValue: 4.5,
    criticalValue: 3.0,
    warningValue: 3.8,
    frequency: 'DAILY',
    isActive: true,
    weight: 0.10
  }
];

export const useKPITracking = () => {
  const [kpiDefinitions, setKpiDefinitions] = useState<KPIDefinition[]>(STANDARD_KPIS);
  const [advisorProfiles, setAdvisorProfiles] = useState<AdvisorPerformanceProfile[]>([]);
  const [allAlerts, setAllAlerts] = useState<AdvancedAlert[]>([]);
  const [isCalculating, setIsCalculating] = useState(false);
  const [lastUpdate, setLastUpdate] = useState<string>(new Date().toISOString());
  const { toast } = useToast();

  const calculateKPIForAdvisor = useCallback(async (advisorId: string, kpi: KPIDefinition): Promise<KPIResult> => {
    try {
      // Obtener datos de Vicidial para el asesor
      const today = new Date().toISOString().split('T')[0];
      const callLog = await vicidialService.getCallLog({
        start_date: today,
        end_date: today,
        user: advisorId
      });

      // Calcular métricas base
      const totalCalls = callLog.length;
      const contacts = callLog.filter(call => call.length_in_sec > 30).length;
      const sales = callLog.filter(call => call.term_reason === 'SALE').length;
      const totalTalkTime = callLog.reduce((sum, call) => sum + call.length_in_sec, 0);
      const workHours = 8; // Asumido, debería venir del sistema de horarios

      let value = 0;
      let historicalData: { date: string; value: number; }[] = [];

      // Calcular valor del KPI según su definición
      switch (kpi.id) {
        case 'CALLS_PER_HOUR':
          value = workHours > 0 ? totalCalls / workHours : 0;
          break;
        case 'CONTACT_RATE':
          value = totalCalls > 0 ? (contacts / totalCalls) * 100 : 0;
          break;
        case 'CONVERSION_RATE':
          value = contacts > 0 ? (sales / contacts) * 100 : 0;
          break;
        case 'AVERAGE_CALL_TIME':
          value = totalCalls > 0 ? totalTalkTime / totalCalls : 0;
          break;
        case 'QUALITY_SCORE':
          // Simulado - en producción vendría de evaluaciones reales
          value = 75 + Math.random() * 25;
          break;
        case 'CUSTOMER_SATISFACTION':
          // Simulado - en producción vendría de encuestas reales
          value = 3.5 + Math.random() * 1.5;
          break;
        default:
          value = 0;
      }

      // Generar datos históricos simulados
      for (let i = 6; i >= 0; i--) {
        const date = new Date();
        date.setDate(date.getDate() - i);
        historicalData.push({
          date: date.toISOString().split('T')[0],
          value: value * (0.8 + Math.random() * 0.4) // Variación ±20%
        });
      }

      const percentage = kpi.targetValue > 0 ? (value / kpi.targetValue) * 100 : 0;
      let status: KPIResult['status'] = 'GOOD';
      
      if (value <= kpi.criticalValue) status = 'CRITICAL';
      else if (value <= kpi.warningValue) status = 'WARNING';
      else if (value >= kpi.targetValue) status = 'EXCELLENT';

      // Determinar tendencia
      const recentTrend = historicalData.slice(-3);
      const averageRecent = recentTrend.reduce((sum, d) => sum + d.value, 0) / recentTrend.length;
      const previousTrend = historicalData.slice(-6, -3);
      const averagePrevious = previousTrend.reduce((sum, d) => sum + d.value, 0) / previousTrend.length;
      
      let trend: KPIResult['trend'] = 'STABLE';
      if (averageRecent > averagePrevious * 1.05) trend = 'IMPROVING';
      else if (averageRecent < averagePrevious * 0.95) trend = 'DECLINING';

      return {
        kpiId: kpi.id,
        advisorId,
        value: Math.round(value * 100) / 100,
        target: kpi.targetValue,
        percentage: Math.round(percentage * 100) / 100,
        status,
        trend,
        lastCalculated: new Date().toISOString(),
        historicalData
      };
    } catch (error) {
      console.error(`Error calculando KPI ${kpi.id} para asesor ${advisorId}:`, error);
      
      // Retornar valores por defecto en caso de error
      return {
        kpiId: kpi.id,
        advisorId,
        value: 0,
        target: kpi.targetValue,
        percentage: 0,
        status: 'CRITICAL',
        trend: 'STABLE',
        lastCalculated: new Date().toISOString(),
        historicalData: []
      };
    }
  }, []);

  const calculateAllKPIsForAdvisor = useCallback(async (advisorId: string, advisorName: string): Promise<AdvisorPerformanceProfile> => {
    const kpiResults: KPIResult[] = [];
    
    for (const kpi of kpiDefinitions.filter(k => k.isActive)) {
      const result = await calculateKPIForAdvisor(advisorId, kpi);
      kpiResults.push(result);
    }

    // Calcular scores por categoría
    const categoryScores = {
      productivity: calculateCategoryScore(kpiResults, 'PRODUCTIVITY'),
      quality: calculateCategoryScore(kpiResults, 'QUALITY'),
      efficiency: calculateCategoryScore(kpiResults, 'EFFICIENCY'),
      revenue: calculateCategoryScore(kpiResults, 'REVENUE'),
      customerSatisfaction: calculateCategoryScore(kpiResults, 'CUSTOMER_SATISFACTION')
    };

    // Calcular score total ponderado
    const totalScore = kpiResults.reduce((sum, result) => {
      const kpi = kpiDefinitions.find(k => k.id === result.kpiId);
      const weight = kpi?.weight || 0;
      return sum + (result.percentage * weight);
    }, 0);

    // Determinar tendencia general
    const improvingKPIs = kpiResults.filter(r => r.trend === 'IMPROVING').length;
    const decliningKPIs = kpiResults.filter(r => r.trend === 'DECLINING').length;
    let performanceTrend: AdvisorPerformanceProfile['performanceTrend'] = 'STABLE';
    if (improvingKPIs > decliningKPIs) performanceTrend = 'IMPROVING';
    else if (decliningKPIs > improvingKPIs) performanceTrend = 'DECLINING';

    // Determinar nivel de riesgo
    const criticalKPIs = kpiResults.filter(r => r.status === 'CRITICAL').length;
    const warningKPIs = kpiResults.filter(r => r.status === 'WARNING').length;
    let riskLevel: AdvisorPerformanceProfile['riskLevel'] = 'LOW';
    if (criticalKPIs > 0) riskLevel = 'CRITICAL';
    else if (warningKPIs > 2) riskLevel = 'HIGH';
    else if (warningKPIs > 0) riskLevel = 'MEDIUM';

    // Identificar fortalezas y áreas de mejora
    const strengths = kpiResults
      .filter(r => r.status === 'EXCELLENT')
      .map(r => kpiDefinitions.find(k => k.id === r.kpiId)?.name || r.kpiId);

    const improvementAreas = kpiResults
      .filter(r => r.status === 'CRITICAL' || r.status === 'WARNING')
      .map(r => kpiDefinitions.find(k => k.id === r.kpiId)?.name || r.kpiId);

    // Generar recomendaciones
    const recommendations = generateRecommendations(kpiResults, kpiDefinitions);

    return {
      advisorId,
      advisorName,
      totalScore: Math.round(totalScore),
      categoryScores,
      kpiResults,
      activeAlerts: allAlerts.filter(alert => alert.advisorId === advisorId && !alert.resolvedAt),
      performanceTrend,
      riskLevel,
      strengths,
      improvementAreas,
      recommendations,
      lastEvaluated: new Date().toISOString(),
      nextEvaluation: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString()
    };
  }, [kpiDefinitions, allAlerts, calculateKPIForAdvisor]);

  const calculateCategoryScore = (results: KPIResult[], category: KPIDefinition['category']): number => {
    const categoryKPIs = kpiDefinitions.filter(k => k.category === category && k.isActive);
    const categoryResults = results.filter(r => 
      categoryKPIs.some(k => k.id === r.kpiId)
    );
    
    if (categoryResults.length === 0) return 0;
    
    const totalWeight = categoryKPIs.reduce((sum, k) => sum + k.weight, 0);
    const weightedScore = categoryResults.reduce((sum, result) => {
      const kpi = categoryKPIs.find(k => k.id === result.kpiId);
      const weight = kpi?.weight || 0;
      return sum + (result.percentage * weight);
    }, 0);
    
    return totalWeight > 0 ? Math.round(weightedScore / totalWeight) : 0;
  };

  const generateRecommendations = (results: KPIResult[], kpis: KPIDefinition[]): string[] => {
    const recommendations: string[] = [];
    
    results.forEach(result => {
      const kpi = kpis.find(k => k.id === result.kpiId);
      if (!kpi) return;
      
      if (result.status === 'CRITICAL') {
        switch (result.kpiId) {
          case 'CALLS_PER_HOUR':
            recommendations.push('Revisar técnicas de marcación y reducir tiempo entre llamadas');
            break;
          case 'CONTACT_RATE':
            recommendations.push('Analizar horarios de llamada y calidad de la base de datos');
            break;
          case 'CONVERSION_RATE':
            recommendations.push('Reforzar técnicas de venta y manejo de objeciones');
            break;
          case 'QUALITY_SCORE':
            recommendations.push('Programar sesión de coaching inmediata');
            break;
          case 'CUSTOMER_SATISFACTION':
            recommendations.push('Revisar técnicas de atención al cliente');
            break;
        }
      } else if (result.status === 'WARNING') {
        switch (result.kpiId) {
          case 'CALLS_PER_HOUR':
            recommendations.push('Optimizar procesos de marcación');
            break;
          case 'CONTACT_RATE':
            recommendations.push('Revisar estrategia de horarios de contacto');
            break;
          case 'CONVERSION_RATE':
            recommendations.push('Reforzar entrenamiento en cierre de ventas');
            break;
        }
      }
    });
    
    return recommendations;
  };

  const generateAlerts = useCallback((profile: AdvisorPerformanceProfile): AdvancedAlert[] => {
    const alerts: AdvancedAlert[] = [];
    
    profile.kpiResults.forEach(result => {
      const kpi = kpiDefinitions.find(k => k.id === result.kpiId);
      if (!kpi) return;
      
      if (result.status === 'CRITICAL') {
        alerts.push({
          id: `ALERT_${profile.advisorId}_${result.kpiId}_${Date.now()}`,
          advisorId: profile.advisorId,
          advisorName: profile.advisorName,
          type: 'KPI_CRITICAL',
          severity: 'CRITICAL',
          kpiId: result.kpiId,
          kpiName: kpi.name,
          currentValue: result.value,
          targetValue: result.target,
          deviation: ((result.target - result.value) / result.target) * 100,
          message: `${kpi.name} está en nivel crítico: ${result.value} ${kpi.unit} (objetivo: ${result.target} ${kpi.unit})`,
          actionRequired: 'Intervención inmediata requerida',
          suggestedActions: [
            'Supervisión directa',
            'Coaching inmediato',
            'Revisión de procesos',
            'Capacitación específica'
          ],
          createdAt: new Date().toISOString(),
          priority: 1,
          autoGenerated: true,
          relatedAlerts: [],
          metadata: {
            kpiCategory: kpi.category,
            trend: result.trend,
            historicalLow: true
          }
        });
      } else if (result.status === 'WARNING') {
        alerts.push({
          id: `ALERT_${profile.advisorId}_${result.kpiId}_${Date.now()}`,
          advisorId: profile.advisorId,
          advisorName: profile.advisorName,
          type: 'KPI_WARNING',
          severity: 'HIGH',
          kpiId: result.kpiId,
          kpiName: kpi.name,
          currentValue: result.value,
          targetValue: result.target,
          deviation: ((result.target - result.value) / result.target) * 100,
          message: `${kpi.name} por debajo del objetivo: ${result.value} ${kpi.unit} (objetivo: ${result.target} ${kpi.unit})`,
          actionRequired: 'Monitoreo y acción correctiva',
          suggestedActions: [
            'Revisión con supervisor',
            'Plan de mejora',
            'Seguimiento diario'
          ],
          createdAt: new Date().toISOString(),
          priority: 2,
          autoGenerated: true,
          relatedAlerts: [],
          metadata: {
            kpiCategory: kpi.category,
            trend: result.trend
          }
        });
      }
    });

    // Alerta por tendencia negativa en múltiples KPIs
    const decliningKPIs = profile.kpiResults.filter(r => r.trend === 'DECLINING');
    if (decliningKPIs.length >= 3) {
      alerts.push({
        id: `ALERT_PATTERN_${profile.advisorId}_${Date.now()}`,
        advisorId: profile.advisorId,
        advisorName: profile.advisorName,
        type: 'PATTERN_ANOMALY',
        severity: 'HIGH',
        currentValue: decliningKPIs.length,
        targetValue: 2,
        deviation: 0,
        message: `Tendencia negativa detectada en ${decliningKPIs.length} KPIs`,
        actionRequired: 'Evaluación integral del rendimiento',
        suggestedActions: [
          'Sesión de coaching extendida',
          'Revisión de procesos de trabajo',
          'Evaluación de carga de trabajo',
          'Análisis de factores externos'
        ],
        createdAt: new Date().toISOString(),
        priority: 1,
        autoGenerated: true,
        relatedAlerts: [],
        metadata: {
          decliningKPIs: decliningKPIs.map(k => k.kpiId),
          patternType: 'MULTIPLE_DECLINE'
        }
      });
    }

    return alerts;
  }, [kpiDefinitions]);

  const updateAdvisorProfiles = useCallback(async () => {
    setIsCalculating(true);
    try {
      // Obtener lista de asesores activos de Vicidial
      const agents = await vicidialService.getLoggedInAgents();
      
      const profiles: AdvisorPerformanceProfile[] = [];
      const newAlerts: AdvancedAlert[] = [];
      
      for (const agent of agents) {
        const profile = await calculateAllKPIsForAdvisor(agent.user, agent.fullName);
        profiles.push(profile);
        
        // Generar alertas para este asesor
        const advisorAlerts = generateAlerts(profile);
        newAlerts.push(...advisorAlerts);
      }
      
      setAdvisorProfiles(profiles);
      setAllAlerts(prev => [...prev.filter(alert => alert.resolvedAt), ...newAlerts]);
      setLastUpdate(new Date().toISOString());
      
      // Notificar alertas críticas
      const criticalAlerts = newAlerts.filter(alert => alert.severity === 'CRITICAL');
      if (criticalAlerts.length > 0) {
        toast({
          title: "Alertas Críticas Detectadas",
          description: `${criticalAlerts.length} alertas críticas requieren atención inmediata`,
          variant: "destructive",
        });
      }
      
    } catch (error) {
      console.error('Error actualizando perfiles de asesores:', error);
      toast({
        title: "Error de Actualización",
        description: "No se pudieron actualizar los KPIs de los asesores",
        variant: "destructive",
      });
    } finally {
      setIsCalculating(false);
    }
  }, [calculateAllKPIsForAdvisor, generateAlerts, toast]);

  const acknowledgeAlert = (alertId: string, acknowledgedBy: string) => {
    setAllAlerts(prev => 
      prev.map(alert => 
        alert.id === alertId 
          ? { ...alert, acknowledgedAt: new Date().toISOString(), acknowledgedBy }
          : alert
      )
    );
  };

  const resolveAlert = (alertId: string, resolvedBy: string) => {
    setAllAlerts(prev => 
      prev.map(alert => 
        alert.id === alertId 
          ? { ...alert, resolvedAt: new Date().toISOString(), resolvedBy }
          : alert
      )
    );
  };

  const escalateAlert = (alertId: string, escalatedTo: string) => {
    setAllAlerts(prev => 
      prev.map(alert => 
        alert.id === alertId 
          ? { ...alert, escalatedAt: new Date().toISOString(), escalatedTo, severity: 'CRITICAL' }
          : alert
      )
    );
  };

  const getAdvisorProfile = (advisorId: string): AdvisorPerformanceProfile | undefined => {
    return advisorProfiles.find(p => p.advisorId === advisorId);
  };

  const getAlertsByAdvisor = (advisorId: string): AdvancedAlert[] => {
    return allAlerts.filter(alert => alert.advisorId === advisorId && !alert.resolvedAt);
  };

  const getCriticalAlerts = (): AdvancedAlert[] => {
    return allAlerts.filter(alert => alert.severity === 'CRITICAL' && !alert.resolvedAt);
  };

  const getTeamPerformanceOverview = () => {
    if (advisorProfiles.length === 0) return null;
    
    const avgTotalScore = advisorProfiles.reduce((sum, p) => sum + p.totalScore, 0) / advisorProfiles.length;
    const criticalAdvisors = advisorProfiles.filter(p => p.riskLevel === 'CRITICAL').length;
    const improvingAdvisors = advisorProfiles.filter(p => p.performanceTrend === 'IMPROVING').length;
    const decliningAdvisors = advisorProfiles.filter(p => p.performanceTrend === 'DECLINING').length;
    
    const avgCategoryScores = {
      productivity: advisorProfiles.reduce((sum, p) => sum + p.categoryScores.productivity, 0) / advisorProfiles.length,
      quality: advisorProfiles.reduce((sum, p) => sum + p.categoryScores.quality, 0) / advisorProfiles.length,
      efficiency: advisorProfiles.reduce((sum, p) => sum + p.categoryScores.efficiency, 0) / advisorProfiles.length,
      revenue: advisorProfiles.reduce((sum, p) => sum + p.categoryScores.revenue, 0) / advisorProfiles.length,
      customerSatisfaction: advisorProfiles.reduce((sum, p) => sum + p.categoryScores.customerSatisfaction, 0) / advisorProfiles.length
    };
    
    return {
      totalAdvisors: advisorProfiles.length,
      avgTotalScore: Math.round(avgTotalScore),
      criticalAdvisors,
      improvingAdvisors,
      decliningAdvisors,
      avgCategoryScores,
      activeAlerts: allAlerts.filter(alert => !alert.resolvedAt).length,
      criticalAlerts: getCriticalAlerts().length
    };
  };

  // Actualización automática cada 5 minutos
  useEffect(() => {
    updateAdvisorProfiles();
    
    const interval = setInterval(updateAdvisorProfiles, 5 * 60 * 1000);
    return () => clearInterval(interval);
  }, [updateAdvisorProfiles]);

  return {
    kpiDefinitions,
    advisorProfiles,
    allAlerts,
    isCalculating,
    lastUpdate,
    updateAdvisorProfiles,
    acknowledgeAlert,
    resolveAlert,
    escalateAlert,
    getAdvisorProfile,
    getAlertsByAdvisor,
    getCriticalAlerts,
    getTeamPerformanceOverview
  };
};
